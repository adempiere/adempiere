/** ****************************************************************************
  * Product: Adempiere ERP & CRM Smart Business Solution                       *
  * This program is free software; you can redistribute it and/or modify it    *
  * under the terms version 2 of the GNU General Public License as published   *
  * by the Free Software Foundation. This program is distributed in the hope   *
  * that it will be useful, but WITHOUT ANY WARRANTY; without even the implied *
  * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.           *
  * See the GNU General Public License for more details.                       *
  * You should have received a copy of the GNU General Public License along    *
  * with this program; if not, write to the Free Software Foundation, Inc.,    *
  * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.                     *
  * For the text or an alternative of this public license, you may reach us    *
  * Copyright (C) 2003-2016 e-Evolution,SC. All Rights Reserved.               *
  * Contributor(s): Victor Perez www.e-evolution.com                           *
  * ****************************************************************************/

package org.eevolution.test

import org.compiere.model.X_M_DiscountSchema
import org.compiere.util.{TimeUtil}
import org.eevolution.dsl._
import org.eevolution.services._
import org.scalatest.{FeatureSpec, GivenWhenThen}

import scala.math.BigDecimal.RoundingMode

/**
  * Test to validate Prices logic
  * eEvolution author Victor Perez <victor.perez@e-evolution.com>, Created by e-Evolution on 27/02/16.
  */
class ValidatePriceListAndDiscountFunctionality extends FeatureSpec
  with AdempiereTestCase
  with GivenWhenThen
  with ProductService
  with PartnerService
  with PriceListService
  with CurrencyService
  with TaxService
  with PriceListSchemaService{
  feature("Validate Product Price logic") {

    info("Creating a new Sales Price List with version with valid date yestarday for the Oak and Azalea Products")
    info("Currently the prices for Oak are  price list 65 , standard price 61.75 and limit price 58.50")
    info("Currently the prices for Azalea are price list 25 , standard price 23.75 and limit price 22.50")

    scenario("Validate functionality for price using standard price list") {
      val IsSOTrx = true
      val PriceList = getListPriceByDefault(true)
      val Azalea = getProductByValue("Azalea Bush")
      val AzaleaListPrice = 25.0
      val AzaleaStandardPrice = 23.75
      val AzaleaLimitPrice = 22.50
      val AzaleaQuantity: BigDecimal = 1.0
      val AzaleaProductPricing = new ProductPricing(Azalea.get_ID, 0, AzaleaQuantity.bigDecimal, IsSOTrx , trxName)
      AzaleaProductPricing.setM_PriceList_ID(PriceList.get_ID)
      AzaleaProductPricing.setPriceDate(Today)
      AzaleaProductPricing.calculatePrice()
      val Oak = getProductByValue("Oak")
      val OakListPrice = 65
      val OakStandardPrice = 61.75
      val OakLimitPrice = 58.50
      val OakQuantity: BigDecimal = 1.0
      val OakProductPricing = new ProductPricing(Oak.get_ID, 0, OakQuantity.bigDecimal, IsSOTrx, trxName)
      OakProductPricing.setM_PriceList_ID(PriceList.get_ID)
      OakProductPricing.setPriceDate(Today)
      OakProductPricing.calculatePrice()
      Given(s"that that date is $Today and the price list is standard")
      When("ask standard sales price for Oak")
      assert(PriceList.getName == "Standard")
      assert(PriceList.get_ID == AzaleaProductPricing.getM_PriceList_ID)
      Then("the price list is " + PriceList.getName)
      assert(AzaleaProductPricing.getPriceList.doubleValue() == AzaleaListPrice.toDouble)
      Then(s"the Azalea product list price $AzaleaListPrice")
      assert(AzaleaProductPricing.getPriceStd.doubleValue() == AzaleaStandardPrice.toDouble)
      Then(s"the Azalea product standard price $AzaleaStandardPrice")
      assert(AzaleaProductPricing.getPriceLimit.doubleValue() == AzaleaLimitPrice.toDouble)
      Then(s"the Azalea product limit price $AzaleaLimitPrice")
      assert(OakProductPricing.getPriceList.doubleValue() == OakListPrice.toDouble)
      Then(s"the Oak product list price $AzaleaListPrice")
      assert(OakProductPricing.getPriceStd.doubleValue() == OakStandardPrice.toDouble)
      Then(s"the Oak product standard price $AzaleaStandardPrice")
      assert(OakProductPricing.getPriceLimit.doubleValue() == OakLimitPrice.toDouble)
      Then(s"the Oak product limit price $OakLimitPrice")
    }

    info("Validate base price list")
    info("a new product is created")
    info("a new price list is created")
    info("a new price list version is created")
    info("the new product is added to new price list and version")
    info("a second price list with the version is created")
    info("the base price list is defined using first list price")

    scenario("Validate functionality for price using standard price list based on a base price list version") {
          val Yesterday = TimeUtil.addDays(Today , -1)
          val HQ = Organization
          val TreeProductCategory = getProductCategoryByValue("Tree")
          val UOMEach = { getUOMByCode("Ea ")}
          assert(UOMEach != null)
          Then("The UOM is : " + UOMEach.getName)
          val USDCurrency = getCurrencyByCode("USD")
          assert(USDCurrency != null)
          Then("the currency is : " + USDCurrency.getISO_Code)
          val StandardTaxCategory = { getTaxCategoryByName("Standard")}
          import org.eevolution.dsl.builder.ProductBuilder
          val newProductValue = "new product"
          val newProductName = "new product name "
          val newProductDescription = "new product description"
          val newProduct : Product = ProductBuilder()
            .withOrganization(HQ)
            .withValue(newProductValue)
            .withName(newProductName)
            .withDescription (newProductDescription)
            .withProductCategory(TreeProductCategory)
            .withTaxCategory(StandardTaxCategory)
            .withUOM(UOMEach)
            .asSold()
            .asPurchased()
            .build()
          Given("base price list need be validate ")
          When("a new product is created")
          assert(newProductValue == newProduct.getValue)
          Then("the Product Value is : " + newProduct.getValue)
          assert(newProductName == newProduct.getName)
          Then("the Product Name is : " + newProduct.getName)
          assert(newProductDescription == newProduct.getDescription)
          Then("the product Description is : " + newProduct.getDescription)
          assert(UOMEach.getC_UOM_ID==newProduct.getC_UOM_ID)
          Then("the product UOM is :" +  UOMEach.getUOMSymbol)
          assert(newProduct.isSold)
          Then("the product is : Sold")
          assert(newProduct.isPurchased)
          Then("the product is : Purchased")
          import org.eevolution.dsl.builder.PriceListBuilder
          val basePriceListName = "Base List Price"
          val basePriceListDescription = "Base List Price Description"
          val basePriceList  = PriceListBuilder()
            .withOrganization(HQ)
            .withName(basePriceListName)
            .withDescription(basePriceListDescription)
            .withCurrency(USDCurrency)
            .withPricePrecision(scala.BigDecimal(2))
            .asSalesPriceList()
            .build()
          assert(basePriceListName == basePriceList.getName)
          Then("the base price list name is :" + basePriceList.getName)
          assert(basePriceListDescription == basePriceList.getDescription)
          Then("the base price list description is :" + basePriceList.getDescription)
          val basePriceListVersionName = "Base Price List Version"
          val basePriceListVersionDescription = "Base Price List Version"
          val basePriceListSchema = getPriceListSchemaByName("Sales 2001")
          assert(basePriceListSchema != null)
          Then("the discount schema is :" + basePriceListSchema.getName)
          import org.eevolution.dsl.builder.PriceListVersionBuilder
          val basePriceListVersion : PriceListVersion = PriceListVersionBuilder()
            .withPriceList(basePriceList)
            .withName(basePriceListVersionName)
            .withDescription(basePriceListVersionDescription)
            .withValidFrom(Yesterday)
            .withPriceListSchema(basePriceListSchema)
            .build()
          assert(basePriceListVersionName == basePriceListVersion.getName)
          Then("the base price list version name is : " + basePriceListVersion.getName)
          assert(basePriceListVersionDescription == basePriceListVersion.getDescription)
          Then("the base price list version description is : " + basePriceListVersion.getDescription)
          assert(basePriceListVersion.getValidFrom.compareTo(Yesterday) <= 0)
          Then("the valid date is : " +  basePriceListVersion.getValidFrom)
          val basePrice = scala.BigDecimal(15.0)
          val basePriceStd = scala.BigDecimal(13.0)
          val basePriceLimit = scala.BigDecimal(10.0)
          import org.eevolution.dsl.builder.PriceListProductBuilder
          val baseProductPrice = PriceListProductBuilder()
            .withPriceListVersion(basePriceListVersion)
            .withProduct(newProduct)
            .withPriceListAmount(basePrice)
            .withPriceStdAmount(basePriceStd)
            .withPriceLimitAmount(basePriceLimit)
            .build()
          assert(baseProductPrice.getM_PriceList_Version_ID == basePriceListVersion.get_ID())
          Then ("the new product price was added in base price version " + basePriceListVersion.getName + " was created")
          assert(newProduct.getM_Product_ID == baseProductPrice.getM_Product_ID)
          Then ("the new product price for  " + newProduct.getName + "was created")
          assert(basePrice.doubleValue() == baseProductPrice.getPriceList.doubleValue())
          assert(basePriceStd.doubleValue() ==  baseProductPrice.getPriceStd.doubleValue())
          assert(basePriceLimit.doubleValue() == baseProductPrice.getPriceLimit.doubleValue())
          Then("the price list is : " + baseProductPrice.getPriceList)
          Then("the price std is : " + baseProductPrice.getPriceStd)
          Then("the price limit is : " + baseProductPrice.getPriceLimit)
          Given("that new price list " + basePriceList.getName + " was created")
          When("calculate price list based on version")
          val IsSOTrx = true
          val baseQuantity =   scala.BigDecimal(10)
          val baseProductPricing = new ProductPricing(newProduct.get_ID, 0, baseQuantity.bigDecimal, IsSOTrx, trxName)
          baseProductPricing.setM_PriceList_Version_ID(basePriceListVersion.get_ID)
          baseProductPricing.setPriceDate(Today)
          baseProductPricing.calculatePrice()
          assert(baseProductPricing.getPriceList.doubleValue() == basePrice.toDouble)
          Then(s"the new product base list price is :  $basePrice")
          assert(baseProductPricing.getPriceStd.doubleValue() == basePriceStd.toDouble)
          Then(s"the new product base standard price $basePriceStd")
          assert(baseProductPricing.getPriceLimit.doubleValue() == basePriceLimit.toDouble)
          Then(s"the new product limit price $basePriceLimit")
          import org.eevolution.dsl.builder.PriceListBuilder
          val secondPriceListName = "Second List Price"
          val secondPriceListDescription = "Second List Price Description"
          val secondPriceList = PriceListBuilder()
            .withOrganization(HQ)
            .withName(secondPriceListName)
            .withDescription(secondPriceListDescription)
            .withCurrency(USDCurrency)
            .withPricePrecision(scala.BigDecimal(2))
            .asSalesPriceList()
            .build()
          assert(secondPriceListName == secondPriceList.getName)
          Then("the second price list name is : " + secondPriceList.getName)
          assert(secondPriceListDescription == secondPriceList.getDescription)
          Then("the second price list description is : " + secondPriceList.getDescription)
          val secondPriceListVersionName = "Second Price List Version"
          val secondPriceListVersionDescription = "Second Price List Version"
          val secondPriceListSchema = getPriceListSchemaByName("Sales 2001")
          assert(secondPriceListSchema != null)
          Then("the discount schema is : " + secondPriceListSchema.getName)
          import org.eevolution.dsl.builder.PriceListVersionBuilder
          val secondPriceListVersion = PriceListVersionBuilder()
            .withPriceList(secondPriceList)
            .withName(secondPriceListVersionName)
            .withDescription(secondPriceListVersionDescription)
            .withValidFrom(Yesterday)
            .withPriceListSchema(secondPriceListSchema)
            .withBasePriceListVersion(basePriceListVersion)
            .build()
          assert(secondPriceListVersionName == secondPriceListVersion.getName)
          Then("the second price list version name is : " + secondPriceListVersion.getName)
          assert(secondPriceListVersionDescription == secondPriceListVersion.getDescription)
          Then("the second price list version description is : " + secondPriceListVersion.getDescription)
          assert(secondPriceListVersion.getValidFrom.compareTo(Yesterday) <= 0)
          Then("the valid date is : " +  secondPriceListVersion.getValidFrom)
          assert(secondPriceListVersion.getM_Pricelist_Version_Base_ID== basePriceListVersion.get_ID)
          Then("the second price version : " + secondPriceListVersion.getName + " set as base price version the : " + basePriceListVersion.getName)
          val secondQuantity =   scala.BigDecimal(10)
          val secondProductPricing = new ProductPricing(newProduct.get_ID, 0, secondQuantity.bigDecimal, IsSOTrx, trxName)
          secondProductPricing.setM_PriceList_ID(secondPriceList.get_ID)
          secondProductPricing.setPriceDate(Today)
          secondProductPricing.calculatePrice()
          assert(secondProductPricing.getPriceList.doubleValue() == basePrice.toDouble)
          Then(s"the new product base list price is :  $basePrice")
          assert(secondProductPricing.getPriceStd.doubleValue() == basePriceStd.toDouble)
          Then(s"the new product base standard price $basePriceStd")
          assert(secondProductPricing.getPriceLimit.doubleValue() == basePriceLimit.toDouble)
          Then(s"the new product limit price $basePriceLimit")
    }

    info("")
    info("a new product is created")
    info("a new price list is created")
    info("a new price list version is created")
    info("the new product is added to new price list and version")
    info("a product break value with Seed Farm Inc. partner")
    info("a break value is added to 12 and price list 13.00 usd , price std 11 usd , price limit 8.00 usd")
    info("a break value is added to 24 and price list 11.00 usd , price std 9 usd , price limit 6.00 usd")

    scenario("Validate functionality for price break with a vendor") {
          val YesterDay = TimeUtil.addDays(Today , -1)
          val HQ = Organization
          val TreeProductCategory = getProductCategoryByValue("Tree")
          val UOMEach = { getUOMByCode("Ea ")}
          assert(UOMEach != null)
          Then("The UOM is : " + UOMEach.getName)
          val USDCurrency = getCurrencyByCode("USD")
          assert(USDCurrency != null)
          Then("the currency is : " + USDCurrency.getISO_Code)
          val StandardTaxCategory = { getTaxCategoryByName("Standard")}
          import org.eevolution.dsl.builder.ProductBuilder
          val newProductValue = "new product break value with vendor"
          val newProductName = "new product break value with vendor name"
          val newProductDescription = "new product break value with vendor description"
          val newProduct : Product = ProductBuilder()
            .withOrganization(HQ)
            .withValue(newProductValue)
            .withName(newProductName)
            .withDescription (newProductDescription)
            .withProductCategory(TreeProductCategory)
            .withTaxCategory(StandardTaxCategory)
            .withUOM(UOMEach)
            .asSold()
            .asPurchased()
            .build()
          Given("base price list need be validate ")
          When("a new product is created")
          assert(newProductValue == newProduct.getValue)
          Then("the Product Value is : " + newProduct.getValue)
          assert(newProductName == newProduct.getName)
          Then("the Product Name is : " + newProduct.getName)
          assert(newProductDescription == newProduct.getDescription)
          Then("the product Description is : " + newProduct.getDescription)
          assert(UOMEach.getC_UOM_ID==newProduct.getC_UOM_ID)
          Then("the product UOM is :" +  UOMEach.getUOMSymbol)
          assert(newProduct.isSold)
          Then("the product is : Sold")
          assert(newProduct.isPurchased)
          Then("the product is : Purchased")
          import org.eevolution.dsl.builder.PriceListBuilder
          val basePriceListName = "Product break with vendor List Price"
          val basePriceListDescription = "Product break with vendor List Price Description"
          val basePriceList  = PriceListBuilder()
            .withOrganization(HQ)
            .withName(basePriceListName)
            .withDescription(basePriceListDescription)
            .withCurrency(USDCurrency)
            .withPricePrecision(scala.BigDecimal(2))
            .asSalesPriceList()
            .build()
          assert(basePriceListName == basePriceList.getName)
          Then("the price list name is :" + basePriceList.getName)
          assert(basePriceListDescription == basePriceList.getDescription)
          Then("the price list description is :" + basePriceList.getDescription)
          val basePriceListVersionName = "Product break with vendor Price List Version"
          val basePriceListVersionDescription = "Product break with vendor Price List Version"
          val basePriceListSchema = getPriceListSchemaByName("Sales 2001")
          assert(basePriceListSchema != null)
          Then("the discount schema is :" + basePriceListSchema.getName)
          import org.eevolution.dsl.builder.PriceListVersionBuilder
          val basePriceListVersion : PriceListVersion = PriceListVersionBuilder()
            .withPriceList(basePriceList)
            .withName(basePriceListVersionName)
            .withDescription(basePriceListVersionDescription)
            .withValidFrom(YesterDay)
            .withPriceListSchema(basePriceListSchema)
            .build()
          assert(basePriceListVersionName == basePriceListVersion.getName)
          Then("the base price list version name is : " + basePriceListVersion.getName)
          assert(basePriceListVersionDescription == basePriceListVersion.getDescription)
          Then("the base price list version description is : " + basePriceListVersion.getDescription)
          assert(basePriceListVersion.getValidFrom.compareTo(YesterDay) <= 0)
          Then("the valid date is : " +  basePriceListVersion.getValidFrom)
          val basePrice = scala.BigDecimal(15.0)
          val basePriceStd = scala.BigDecimal(13.0)
          val basePriceLimit = scala.BigDecimal(10.0)
          import org.eevolution.dsl.builder.PriceListProductBuilder
          val baseProductPrice = PriceListProductBuilder()
            .withPriceListVersion(basePriceListVersion)
            .withProduct(newProduct)
            .withPriceListAmount(basePrice)
            .withPriceStdAmount(basePriceStd)
            .withPriceLimitAmount(basePriceLimit)
            .build()
          assert(baseProductPrice.getM_PriceList_Version_ID == basePriceListVersion.get_ID())
          Then ("the new product price was added in base price version " + basePriceListVersion.getName + " was created")
          assert(newProduct.getM_Product_ID == baseProductPrice.getM_Product_ID)
          Then ("the new product price for  " + newProduct.getName + "was created")
          assert(basePrice.doubleValue() == baseProductPrice.getPriceList.doubleValue())
          assert(basePriceStd.doubleValue() ==  baseProductPrice.getPriceStd.doubleValue())
          assert(basePriceLimit.doubleValue() == baseProductPrice.getPriceLimit.doubleValue())
          Then("the price list is : " + baseProductPrice.getPriceList)
          Then("the price std is : " + baseProductPrice.getPriceStd)
          Then("the price limit is : " + baseProductPrice.getPriceLimit)
          val IsSOTrx = true
          val firstBreakValue = scala.BigDecimal(12.0)
          val firstQuantityBreakValue = scala.BigDecimal(14.0)
          val firstBreakPrice = scala.BigDecimal(13.0)
          val firstBreakPriceStd = scala.BigDecimal(11.0)
          val firstBreakPriceLimit = scala.BigDecimal(8.0)
          val secondBreakValue = scala.BigDecimal(24.0)
          val secondQuantityBreakValue = scala.BigDecimal(26.0)
          val secondBreakPrice = scala.BigDecimal(11.0)
          val secondBreakPriceStd = scala.BigDecimal(9.0)
          val secondBreakPriceLimit = scala.BigDecimal(6.0)
          val seedFarmPartner = getPartnerByValue("SeedFarm")
          import org.eevolution.dsl.builder.PriceListProductBreakBuilder
          val firstProductBreak = PriceListProductBreakBuilder()
            .withPriceListVersion(basePriceListVersion)
            .withProduct(newProduct)
            .withPartner(seedFarmPartner)
            .withBreakValue(firstBreakValue)
            .withPriceListAmount(firstBreakPrice)
            .withPriceStdAmount(firstBreakPriceStd)
            .withPriceLimitAmount(firstBreakPriceLimit)
            .build()
          Given("a first product break value was created")
          assert(seedFarmPartner.getValue == "SeedFarm")
          Then("first product break for business partner " + seedFarmPartner.getName)
          assert(firstProductBreak.getBreakValue.doubleValue() == firstBreakValue.doubleValue())
          Then("first product break value is : " + firstProductBreak.getBreakValue)
          assert(firstProductBreak.getPriceList.doubleValue() == firstBreakPrice.doubleValue())
          Then("first product break price list" + firstProductBreak.getPriceList)
          assert(firstProductBreak.getPriceStd.doubleValue() == firstBreakPriceStd.doubleValue())
          Then("first product break standard price " + firstProductBreak.getPriceStd)
          assert(firstProductBreak.getPriceLimit.doubleValue() == firstBreakPriceLimit.doubleValue())
          Then("first product break price limit " + firstProductBreak.getPriceLimit)
          val secondProductBreak = PriceListProductBreakBuilder()
            .withPriceListVersion(basePriceListVersion)
            .withProduct(newProduct)
            .withPartner(seedFarmPartner)
            .withBreakValue(secondBreakValue)
            .withPriceListAmount(secondBreakPrice)
            .withPriceStdAmount(secondBreakPriceStd)
            .withPriceLimitAmount(secondBreakPriceLimit)
            .build()
          Given("a second product break value was created")
          assert(seedFarmPartner.getValue == "SeedFarm")
          Then("second product break for business partner " + seedFarmPartner.getName)
          assert(secondProductBreak.getBreakValue.doubleValue() == secondBreakValue.doubleValue())
          Then("second product break value is : " + secondProductBreak.getBreakValue)
          assert(secondProductBreak.getPriceList.doubleValue() == secondBreakPrice.doubleValue())
          Then("second product break price list" + secondProductBreak.getPriceList)
          assert(secondProductBreak.getPriceStd.doubleValue() == secondBreakPriceStd.doubleValue())
          Then("second product break standatd price " + secondProductBreak.getPriceStd)
          assert(secondProductBreak.getPriceLimit.doubleValue() == secondBreakPriceLimit.doubleValue())
          Then("second product break price limit " + secondProductBreak.getPriceLimit)
          val firstProductPricing = new ProductPricing(newProduct.get_ID, seedFarmPartner.get_ID , firstQuantityBreakValue.bigDecimal, IsSOTrx, trxName)
          firstProductPricing.setM_PriceList_ID(basePriceList.get_ID)
          firstProductPricing.setPriceDate(Today)
          firstProductPricing.calculatePrice()
          assert(firstProductPricing.getPriceList.doubleValue() == firstBreakPrice.toDouble)
          Then(s"the new product first break value list price is :  $firstBreakPrice")
          assert(firstProductPricing.getPriceStd.doubleValue() == firstBreakPriceStd.toDouble)
          Then(s"the new product first break value standard price $firstBreakPriceStd")
          assert(firstProductPricing.getPriceLimit.doubleValue() == firstBreakPriceLimit.toDouble)
          Then(s"the new product first break value limit price $firstBreakPriceLimit")
          val secondProductPricing = new ProductPricing(newProduct.get_ID, seedFarmPartner.get_ID, secondQuantityBreakValue.bigDecimal, IsSOTrx, trxName)
          secondProductPricing.setM_PriceList_Version_ID(basePriceListVersion.get_ID)
          secondProductPricing.setPriceDate(Today)
          secondProductPricing.calculatePrice()
          assert(secondProductBreak.getPriceList.doubleValue() == secondBreakPrice.toDouble)
          Then(s"the new product second break value list price is :  $secondBreakPrice")
          assert(secondProductBreak.getPriceStd.doubleValue() == secondBreakPriceStd.toDouble)
          Then(s"the new product second break value  standard price $secondBreakPriceStd")
          assert(secondProductBreak.getPriceLimit.doubleValue() == secondBreakPriceLimit.toDouble)
          Then(s"the new product second break value limit price $secondBreakPriceLimit")
    }

        scenario("Validate functionality for price break without a vendor") {
          val Yesterday = TimeUtil.addDays(Today , -1)
          val HQ = Organization
          val TreeProductCategory = getProductCategoryByValue("Tree")
          val UOMEach = { getUOMByCode("Ea ")}
          assert(UOMEach != null)
          Then("The UOM is : " + UOMEach.getName)
          val USDCurrency = getCurrencyByCode("USD")
          assert(USDCurrency != null)
          Then("the currency is : " + USDCurrency.getISO_Code)
          val StandardTaxCategory = { getTaxCategoryByName("Standard")}
          import org.eevolution.dsl.builder.ProductBuilder
          val newProductValue = "new product break value without vendor"
          val newProductName = "new product break value without vendor name"
          val newProductDescription = "new product break value without vendor description"
          val newProduct : Product = ProductBuilder()
            .withOrganization(HQ)
            .withValue(newProductValue)
            .withName(newProductName)
            .withDescription (newProductDescription)
            .withProductCategory(TreeProductCategory)
            .withTaxCategory(StandardTaxCategory)
            .withUOM(UOMEach)
            .asSold()
            .asPurchased()
            .build()
          Given("base price list need be validate ")
          When("a new product is created")
          assert(newProductValue == newProduct.getValue)
          Then("the Product Value is : " + newProduct.getValue)
          assert(newProductName == newProduct.getName)
          Then("the Product Name is : " + newProduct.getName)
          assert(newProductDescription == newProduct.getDescription)
          Then("the product Description is : " + newProduct.getDescription)
          assert(UOMEach.getC_UOM_ID==newProduct.getC_UOM_ID)
          Then("the product UOM is :" +  UOMEach.getUOMSymbol)
          assert(newProduct.isSold)
          Then("the product is : Sold")
          assert(newProduct.isPurchased)
          Then("the product is : Purchased")
          import org.eevolution.dsl.builder.PriceListBuilder
          val basePriceListName = "Product break without vendor List Price"
          val basePriceListDescription = "Product break without vendor List Price Description"
          val basePriceList  = PriceListBuilder()
            .withOrganization(HQ)
            .withName(basePriceListName)
            .withDescription(basePriceListDescription)
            .withCurrency(USDCurrency)
            .withPricePrecision(scala.BigDecimal(2))
            .asSalesPriceList()
            .build()
          assert(basePriceListName == basePriceList.getName)
          Then("the price list name is :" + basePriceList.getName)
          assert(basePriceListDescription == basePriceList.getDescription)
          Then("the price list description is :" + basePriceList.getDescription)
          val basePriceListVersionName = "Product break without vendor Price List Version"
          val basePriceListVersionDescription = "Product break without vendor Price List Version"
          val basePriceListSchema = getPriceListSchemaByName("Sales 2001")
          assert(basePriceListSchema != null)
          Then("the discount schema is :" + basePriceListSchema.getName)
          import org.eevolution.dsl.builder.PriceListVersionBuilder
          val basePriceListVersion : PriceListVersion = PriceListVersionBuilder()
            .withPriceList(basePriceList)
            .withName(basePriceListVersionName)
            .withDescription(basePriceListVersionDescription)
            .withValidFrom(Yesterday)
            .withPriceListSchema(basePriceListSchema)
            .build()
          assert(basePriceListVersionName == basePriceListVersion.getName)
          Then("the base price list version name is : " + basePriceListVersion.getName)
          assert(basePriceListVersionDescription == basePriceListVersion.getDescription)
          Then("the base price list version description is : " + basePriceListVersion.getDescription)
          assert(basePriceListVersion.getValidFrom.compareTo(Yesterday) <= 0)
          Then("the valid date is : " +  basePriceListVersion.getValidFrom)
          val basePrice = scala.BigDecimal(15.0)
          val basePriceStd = scala.BigDecimal(13.0)
          val basePriceLimit = scala.BigDecimal(10.0)
          import org.eevolution.dsl.builder.PriceListProductBuilder
          val baseProductPrice = PriceListProductBuilder()
            .withPriceListVersion(basePriceListVersion)
            .withProduct(newProduct)
            .withPriceListAmount(basePrice)
            .withPriceStdAmount(basePriceStd)
            .withPriceLimitAmount(basePriceLimit)
            .build()
          assert(baseProductPrice.getM_PriceList_Version_ID == basePriceListVersion.get_ID())
          Then ("the new product price was added in base price version " + basePriceListVersion.getName + " was created")
          assert(newProduct.getM_Product_ID == baseProductPrice.getM_Product_ID)
          Then ("the new product price for  " + newProduct.getName + "was created")
          assert(basePrice.doubleValue() == baseProductPrice.getPriceList.doubleValue())
          assert(basePriceStd.doubleValue() ==  baseProductPrice.getPriceStd.doubleValue())
          assert(basePriceLimit.doubleValue() == baseProductPrice.getPriceLimit.doubleValue())
          Then("the price list is : " + baseProductPrice.getPriceList)
          Then("the price std is : " + baseProductPrice.getPriceStd)
          Then("the price limit is : " + baseProductPrice.getPriceLimit)
          val IsSOTrx = true
          val firstBreakValue = scala.BigDecimal(12.0)
          val firstQuantityBreakValue = scala.BigDecimal(14.0)
          val firstBreakPrice = scala.BigDecimal(13.0)
          val firstBreakPriceStd = scala.BigDecimal(11.0)
          val firstBreakPriceLimit = scala.BigDecimal(8.0)
          val secondBreakValue = scala.BigDecimal(24.0)
          val secondQuantityBreakValue = scala.BigDecimal(26.0)
          val secondBreakPrice = scala.BigDecimal(11.0)
          val secondBreakPriceStd = scala.BigDecimal(9.0)
          val secondBreakPriceLimit = scala.BigDecimal(6.0)
          val seedFarmPartner = getPartnerByValue("SeedFarm")
          val patioPartner = getPartnerByValue("Patio")
          import org.eevolution.dsl.builder.PriceListProductBreakBuilder
          val firstProductBreak = PriceListProductBreakBuilder()
            .withPriceListVersion(basePriceListVersion)
            .withProduct(newProduct)
            .withBreakValue(firstBreakValue)
            .withPriceListAmount(firstBreakPrice)
            .withPriceStdAmount(firstBreakPriceStd)
            .withPriceLimitAmount(firstBreakPriceLimit)
            .build()
          Given("a first product break value was created")
          assert(seedFarmPartner.getValue == "SeedFarm")
          Then("first product break for business partner " + seedFarmPartner.getName)
          assert(firstProductBreak.getBreakValue.doubleValue() == firstBreakValue.doubleValue())
          Then("first product break value is : " + firstProductBreak.getBreakValue)
          assert(firstProductBreak.getPriceList.doubleValue() == firstBreakPrice.doubleValue())
          Then("first product break price list" + firstProductBreak.getPriceList)
          assert(firstProductBreak.getPriceStd.doubleValue() == firstBreakPriceStd.doubleValue())
          Then("first product break standard price " + firstProductBreak.getPriceStd)
          assert(firstProductBreak.getPriceLimit.doubleValue() == firstBreakPriceLimit.doubleValue())
          Then("first product break price limit " + firstProductBreak.getPriceLimit)
          val secondProductBreak = PriceListProductBreakBuilder()
            .withPriceListVersion(basePriceListVersion)
            .withProduct(newProduct)
            .withBreakValue(secondBreakValue)
            .withPriceListAmount(secondBreakPrice)
            .withPriceStdAmount(secondBreakPriceStd)
            .withPriceLimitAmount(secondBreakPriceLimit)
            .build()
          Given("a second product break value was created")
          assert(seedFarmPartner.getValue == "SeedFarm")
          Then("second product break for business partner " + seedFarmPartner.getName)
          assert(secondProductBreak.getBreakValue.doubleValue() == secondBreakValue.doubleValue())
          Then("second product break value is : " + secondProductBreak.getBreakValue)
          assert(secondProductBreak.getPriceList.doubleValue() == secondBreakPrice.doubleValue())
          Then("second product break price list" + secondProductBreak.getPriceList)
          assert(secondProductBreak.getPriceStd.doubleValue() == secondBreakPriceStd.doubleValue())
          Then("second product break standatd price " + secondProductBreak.getPriceStd)
          assert(secondProductBreak.getPriceLimit.doubleValue() == secondBreakPriceLimit.doubleValue())
          Then("second product break price limit " + secondProductBreak.getPriceLimit)
          val firstProductPricing = new ProductPricing(newProduct.get_ID, 0 , firstQuantityBreakValue.bigDecimal, IsSOTrx, trxName)
          firstProductPricing.setM_PriceList_ID(basePriceList.get_ID)
          firstProductPricing.setPriceDate(Today)
          firstProductPricing.calculatePrice()
          assert(firstProductPricing.getPriceList.doubleValue() == firstBreakPrice.toDouble)
          Then(s"the new product first break value list price is :  $firstBreakPrice")
          assert(firstProductPricing.getPriceStd.doubleValue() == firstBreakPriceStd.toDouble)
          Then(s"the new product first break value standard price $firstBreakPriceStd")
          assert(firstProductPricing.getPriceLimit.doubleValue() == firstBreakPriceLimit.toDouble)
          Then(s"the new product first break value limit price $firstBreakPriceLimit")
          val secondProductPricing = new ProductPricing(newProduct.get_ID, 0 , secondQuantityBreakValue.bigDecimal, IsSOTrx, trxName)
          secondProductPricing.setM_PriceList_Version_ID(basePriceListVersion.get_ID)
          secondProductPricing.setPriceDate(Today)
          secondProductPricing.calculatePrice()
          assert(secondProductBreak.getPriceList.doubleValue() == secondBreakPrice.toDouble)
          Then(s"the new product second break value list price is :  $secondBreakPrice")
          assert(secondProductBreak.getPriceStd.doubleValue() == secondBreakPriceStd.toDouble)
          Then(s"the new product second break value  standard price $secondBreakPriceStd")
          assert(secondProductBreak.getPriceLimit.doubleValue() == secondBreakPriceLimit.toDouble)
          Then(s"the new product second break value limit price $secondBreakPriceLimit")
    }

    scenario("Validate functionality for price break with a vendor based on base price list version") {
      val IsSOTrx = true
      val Yesterday = TimeUtil.addDays(Today , -1)
      val HQ = Organization
      val TreeProductCategory = getProductCategoryByValue("Tree")
      val UOMEach = { getUOMByCode("Ea ")}
      assert(UOMEach != null)
      Then("The UOM is : " + UOMEach.getName)
      val USDCurrency = getCurrencyByCode("USD")
      assert(USDCurrency != null)
      Then("the currency is : " + USDCurrency.getISO_Code)
      val StandardTaxCategory = { getTaxCategoryByName("Standard")}
      import org.eevolution.dsl.builder.ProductBuilder
      val newProductValue = "new product vendor base break value"
      val newProductName = "new product vendor name base break value"
      val newProductDescription = "new product vendor break value description"
      val newProduct : Product = ProductBuilder()
        .withOrganization(HQ)
        .withValue(newProductValue)
        .withName(newProductName)
        .withDescription (newProductDescription)
        .withProductCategory(TreeProductCategory)
        .withTaxCategory(StandardTaxCategory)
        .withUOM(UOMEach)
        .asSold()
        .asPurchased()
        .build()
      Given("base price list need be validate ")
      When("a new product is created")
      assert(newProductValue == newProduct.getValue)
      Then("the Product Value is : " + newProduct.getValue)
      assert(newProductName == newProduct.getName)
      Then("the Product Name is : " + newProduct.getName)
      assert(newProductDescription == newProduct.getDescription)
      Then("the product Description is : " + newProduct.getDescription)
      assert(UOMEach.getC_UOM_ID==newProduct.getC_UOM_ID)
      Then("the product UOM is :" +  UOMEach.getUOMSymbol)
      assert(newProduct.isSold)
      Then("the product is : Sold")
      assert(newProduct.isPurchased)
      Then("the product is : Purchased")
      import org.eevolution.dsl.builder.PriceListBuilder
      val basePriceListName = "Product break with vendor base List Price"
      val basePriceListDescription = "Product break with vendor base List Price Description"
      val basePriceList  = PriceListBuilder()
        .withOrganization(HQ)
        .withName(basePriceListName)
        .withDescription(basePriceListDescription)
        .withCurrency(USDCurrency)
        .withPricePrecision(scala.BigDecimal(2))
        .asSalesPriceList()
        .build()
      assert(basePriceListName == basePriceList.getName)
      Then("the price list name is :" + basePriceList.getName)
      assert(basePriceListDescription == basePriceList.getDescription)
      Then("the price list description is :" + basePriceList.getDescription)
      val basePriceListVersionName = "Product break with vendor Price List Version"
      val basePriceListVersionDescription = "Product break with vendor Price List Version"
      val basePriceListSchema = getPriceListSchemaByName("Sales 2001")
      assert(basePriceListSchema != null)
      Then("the discount schema is :" + basePriceListSchema.getName)
      import org.eevolution.dsl.builder.PriceListVersionBuilder
      val basePriceListVersion : PriceListVersion = PriceListVersionBuilder()
        .withPriceList(basePriceList)
        .withName(basePriceListVersionName)
        .withDescription(basePriceListVersionDescription)
        .withValidFrom(Yesterday)
        .withPriceListSchema(basePriceListSchema)
        .build()
      assert(basePriceListVersionName == basePriceListVersion.getName)
      Then("the base price list version name is : " + basePriceListVersion.getName)
      assert(basePriceListVersionDescription == basePriceListVersion.getDescription)
      Then("the base price list version description is : " + basePriceListVersion.getDescription)
      assert(basePriceListVersion.getValidFrom.compareTo(Yesterday) <= 0)
      Then("the valid date is : " +  basePriceListVersion.getValidFrom)
      val basePrice = scala.BigDecimal(15.0)
      val basePriceStd = scala.BigDecimal(13.0)
      val basePriceLimit = scala.BigDecimal(10.0)
      import org.eevolution.dsl.builder.PriceListProductBuilder
      val baseProductPrice = PriceListProductBuilder()
        .withPriceListVersion(basePriceListVersion)
        .withProduct(newProduct)
        .withPriceListAmount(basePrice)
        .withPriceStdAmount(basePriceStd)
        .withPriceLimitAmount(basePriceLimit)
        .build()
      assert(baseProductPrice.getM_PriceList_Version_ID == basePriceListVersion.get_ID())
      Then ("the new product price was added in base price version " + basePriceListVersion.getName + " was created")
      assert(newProduct.getM_Product_ID == baseProductPrice.getM_Product_ID)
      Then ("the new product price for  " + newProduct.getName + "was created")
      assert(basePrice.doubleValue() == baseProductPrice.getPriceList.doubleValue())
      assert(basePriceStd.doubleValue() ==  baseProductPrice.getPriceStd.doubleValue())
      assert(basePriceLimit.doubleValue() == baseProductPrice.getPriceLimit.doubleValue())
      Then("the price list is : " + baseProductPrice.getPriceList)
      Then("the price std is : " + baseProductPrice.getPriceStd)
      Then("the price limit is : " + baseProductPrice.getPriceLimit)

      val baseFirstBreakValue = scala.BigDecimal(12.0)
      val baseFirstBreakPrice = scala.BigDecimal(8.0)
      val baseFirstBreakPriceStd = scala.BigDecimal(6.0)
      val baseFirstBreakPriceLimit = scala.BigDecimal(3.0)
      val baseSecondBreakValue = scala.BigDecimal(24.0)
      val baseSecondQuantityBreakValue = scala.BigDecimal(26.0)
      val baseSecondBreakPrice = scala.BigDecimal(6.0)
      val baseSecondBreakPriceStd = scala.BigDecimal(4.0)
      val baseSecondBreakPriceLimit = scala.BigDecimal(1.0)
      val seedFarmPartner = getPartnerByValue("SeedFarm")
      import org.eevolution.dsl.builder.PriceListProductBreakBuilder
      val baseFirstProductBreak = PriceListProductBreakBuilder()
        .withPriceListVersion(basePriceListVersion)
        .withProduct(newProduct)
        .withPartner(seedFarmPartner)
        .withBreakValue(baseFirstBreakValue)
        .withPriceListAmount(baseFirstBreakPrice)
        .withPriceStdAmount(baseFirstBreakPriceStd)
        .withPriceLimitAmount(baseFirstBreakPriceLimit)
        .build()
      Given("a first product break value was created")
      assert(seedFarmPartner.getValue == "SeedFarm")
      Then("first product break for business partner " + seedFarmPartner.getName)
      assert(baseFirstProductBreak.getBreakValue.doubleValue() == baseFirstBreakValue.doubleValue())
      Then("first product break value is : " + baseFirstProductBreak.getBreakValue)
      assert(baseFirstProductBreak.getPriceList.doubleValue() == baseFirstBreakPrice.doubleValue())
      Then("first product break base price list" + baseFirstProductBreak.getPriceList)
      assert(baseFirstProductBreak.getPriceStd.doubleValue() == baseFirstBreakPriceStd.doubleValue())
      Then("first product break base standard price " + baseFirstProductBreak.getPriceStd)
      assert(baseFirstProductBreak.getPriceLimit.doubleValue() == baseFirstBreakPriceLimit.doubleValue())
      Then("first product break base price limit " + baseFirstProductBreak.getPriceLimit)
      val baseSecondProductBreak = PriceListProductBreakBuilder()
        .withPriceListVersion(basePriceListVersion)
        .withProduct(newProduct)
        .withPartner(seedFarmPartner)
        .withBreakValue(baseSecondBreakValue)
        .withPriceListAmount(baseSecondBreakPrice)
        .withPriceStdAmount(baseSecondBreakPriceStd)
        .withPriceLimitAmount(baseSecondBreakPriceLimit)
        .build()
      Given("a second product break value was created")
      assert(seedFarmPartner.getValue == "SeedFarm")
      Then("second product break for business partner " + seedFarmPartner.getName)
      assert(baseSecondProductBreak.getBreakValue.doubleValue() == baseSecondBreakValue.doubleValue())
      Then("second product break value is : " + baseSecondProductBreak.getBreakValue)
      assert(baseSecondProductBreak.getPriceList.doubleValue() == baseSecondBreakPrice.doubleValue())
      Then("second product break price list" + baseSecondProductBreak.getPriceList)
      assert(baseSecondProductBreak.getPriceStd.doubleValue() == baseSecondBreakPriceStd.doubleValue())
      Then("second product break standatd price " + baseSecondProductBreak.getPriceStd)
      assert(baseSecondProductBreak.getPriceLimit.doubleValue() == baseSecondBreakPriceLimit.doubleValue())
      Then("second product break price limit " + baseSecondProductBreak.getPriceLimit)


      import org.eevolution.dsl.builder.PriceListBuilder
      val secondPriceListName = "Second Product break with vendor List Price"
      val secondPriceListDescription = "Second Product break with vendor List Price Description"
      val secondPriceList = PriceListBuilder()
        .withOrganization(HQ)
        .withName(secondPriceListName)
        .withDescription(secondPriceListDescription)
        .withCurrency(USDCurrency)
        .withPricePrecision(scala.BigDecimal(2))
        .asSalesPriceList()
        .build()
      assert(secondPriceListName == secondPriceList.getName)
      Then("the second price list name is : " + secondPriceList.getName)
      assert(secondPriceListDescription == secondPriceList.getDescription)
      Then("the second price list description is : " + secondPriceList.getDescription)
      val secondPriceListVersionName = "Second Product break with vendor Price List Version"
      val secondPriceListVersionDescription = "Second Product break with vendor Price List Version"
      val secondPriceListSchema = getPriceListSchemaByName("Sales 2001")
      assert(secondPriceListSchema != null)
      Then("the discount schema is : " + secondPriceListSchema.getName)
      import org.eevolution.dsl.builder.PriceListVersionBuilder
      val secondPriceListVersion = PriceListVersionBuilder()
        .withPriceList(secondPriceList)
        .withName(secondPriceListVersionName)
        .withDescription(secondPriceListVersionDescription)
        .withValidFrom(Yesterday)
        .withPriceListSchema(secondPriceListSchema)
        .withBasePriceListVersion(basePriceListVersion)
        .build()
      assert(secondPriceListVersionName == secondPriceListVersion.getName)
      Then("the second Product break with vendor price list version name is : " + secondPriceListVersion.getName)
      assert(secondPriceListVersionDescription == secondPriceListVersion.getDescription)
      Then("the second Product break with vendor price list version description is : " + secondPriceListVersion.getDescription)
      assert(secondPriceListVersion.getValidFrom.compareTo(Yesterday) <= 0)
      Then("the valid date is : " +  secondPriceListVersion.getValidFrom)
      assert(secondPriceListVersion.getM_Pricelist_Version_Base_ID== basePriceListVersion.get_ID)
      Then("the second price version : " + secondPriceListVersion.getName + " set as base price version the : " + basePriceListVersion.getName)

      val firstProductPricing = new ProductPricing(newProduct.get_ID, seedFarmPartner.get_ID , baseFirstBreakValue.bigDecimal, IsSOTrx, trxName)
      firstProductPricing.setM_PriceList_ID(secondPriceList.get_ID)
      firstProductPricing.setPriceDate(Today)
      firstProductPricing.calculatePrice()
      assert(firstProductPricing.getPriceList.doubleValue() == baseFirstBreakPrice.toDouble)
      Then(s"the new product first break value list price is :  $baseFirstBreakPrice")
      assert(firstProductPricing.getPriceStd.doubleValue() == baseFirstBreakPriceStd.toDouble)
      Then(s"the new product first break value standard price $baseFirstBreakPriceStd")
      assert(firstProductPricing.getPriceLimit.doubleValue() == baseFirstBreakPriceLimit.toDouble)
      Then(s"the new product first break value limit price $baseFirstBreakPriceLimit")
      val secondProductPricing = new ProductPricing(newProduct.get_ID, seedFarmPartner.get_ID, baseSecondQuantityBreakValue.bigDecimal, IsSOTrx, trxName)
      secondProductPricing.setM_PriceList_Version_ID(secondPriceListVersion.get_ID)
      secondProductPricing.setPriceDate(Today)
      secondProductPricing.calculatePrice()
      assert(baseSecondProductBreak.getPriceList.doubleValue() == baseSecondBreakPrice.toDouble)
      Then(s"the new product second break value list price is :  $baseSecondBreakPrice")
      assert(baseSecondProductBreak.getPriceStd.doubleValue() == baseSecondBreakPriceStd.toDouble)
      Then(s"the new product second break value  standard price $baseSecondBreakPriceStd")
      assert(baseSecondProductBreak.getPriceLimit.doubleValue() == baseSecondBreakPriceLimit.toDouble)
      Then(s"the new product second break value limit price $baseSecondBreakPriceLimit")
    }

    scenario("Validate functionality for price break without a vendor based on base price list version") {
      val IsSOTrx = true
      val Yesterday = TimeUtil.addDays(Today , -1)
      val HQ = Organization
      val TreeProductCategory = getProductCategoryByValue("Tree")
      val UOMEach = { getUOMByCode("Ea ")}
      assert(UOMEach != null)
      Then("The UOM is : " + UOMEach.getName)
      val USDCurrency = getCurrencyByCode("USD")
      assert(USDCurrency != null)
      Then("the currency is : " + USDCurrency.getISO_Code)
      val StandardTaxCategory = { getTaxCategoryByName("Standard")}
      import org.eevolution.dsl.builder.ProductBuilder
      val newProductValue = "new product without vendor base break"
      val newProductName = "new product without vendor name base break"
      val newProductDescription = "new product without vendor break description"
      val newProduct : Product = ProductBuilder()
        .withOrganization(HQ)
        .withValue(newProductValue)
        .withName(newProductName)
        .withDescription (newProductDescription)
        .withProductCategory(TreeProductCategory)
        .withTaxCategory(StandardTaxCategory)
        .withUOM(UOMEach)
        .asSold()
        .asPurchased()
        .build()
      Given("base price list need be validate ")
      When("a new product is created")
      assert(newProductValue == newProduct.getValue)
      Then("the Product Value is : " + newProduct.getValue)
      assert(newProductName == newProduct.getName)
      Then("the Product Name is : " + newProduct.getName)
      assert(newProductDescription == newProduct.getDescription)
      Then("the product Description is : " + newProduct.getDescription)
      assert(UOMEach.getC_UOM_ID==newProduct.getC_UOM_ID)
      Then("the product UOM is :" +  UOMEach.getUOMSymbol)
      assert(newProduct.isSold)
      Then("the product is : Sold")
      assert(newProduct.isPurchased)
      Then("the product is : Purchased")
      import org.eevolution.dsl.builder.PriceListBuilder
      val basePriceListName = "Product break without vendor base List Price"
      val basePriceListDescription = "Product break without vendor base List Price Description"
      val basePriceList  = PriceListBuilder()
        .withOrganization(HQ)
        .withName(basePriceListName)
        .withDescription(basePriceListDescription)
        .withCurrency(USDCurrency)
        .withPricePrecision(scala.BigDecimal(2))
        .asSalesPriceList()
        .build()
      assert(basePriceListName == basePriceList.getName)
      Then("the price list name is :" + basePriceList.getName)
      assert(basePriceListDescription == basePriceList.getDescription)
      Then("the price list description is :" + basePriceList.getDescription)
      val basePriceListVersionName = "Product break without vendor Price List Version"
      val basePriceListVersionDescription = "Product break without vendor Price List Version"
      val basePriceListSchema = getPriceListSchemaByName("Sales 2001")
      assert(basePriceListSchema != null)
      Then("the discount schema is :" + basePriceListSchema.getName)
      import org.eevolution.dsl.builder.PriceListVersionBuilder
      val basePriceListVersion : PriceListVersion = PriceListVersionBuilder()
        .withPriceList(basePriceList)
        .withName(basePriceListVersionName)
        .withDescription(basePriceListVersionDescription)
        .withValidFrom(Yesterday)
        .withPriceListSchema(basePriceListSchema)
        .build()
      assert(basePriceListVersionName == basePriceListVersion.getName)
      Then("the base price list version name is : " + basePriceListVersion.getName)
      assert(basePriceListVersionDescription == basePriceListVersion.getDescription)
      Then("the base price list version description is : " + basePriceListVersion.getDescription)
      assert(basePriceListVersion.getValidFrom.compareTo(Yesterday) <= 0)
      Then("the valid date is : " +  basePriceListVersion.getValidFrom)
      val basePrice = scala.BigDecimal(15.0)
      val basePriceStd = scala.BigDecimal(13.0)
      val basePriceLimit = scala.BigDecimal(10.0)
      import org.eevolution.dsl.builder.PriceListProductBuilder
      val baseProductPrice = PriceListProductBuilder()
        .withPriceListVersion(basePriceListVersion)
        .withProduct(newProduct)
        .withPriceListAmount(basePrice)
        .withPriceStdAmount(basePriceStd)
        .withPriceLimitAmount(basePriceLimit)
        .build()
      assert(baseProductPrice.getM_PriceList_Version_ID == basePriceListVersion.get_ID())
      Then ("the new product price was added in base price version " + basePriceListVersion.getName + " was created")
      assert(newProduct.getM_Product_ID == baseProductPrice.getM_Product_ID)
      Then ("the new product price for  " + newProduct.getName + "was created")
      assert(basePrice.doubleValue() == baseProductPrice.getPriceList.doubleValue())
      assert(basePriceStd.doubleValue() ==  baseProductPrice.getPriceStd.doubleValue())
      assert(basePriceLimit.doubleValue() == baseProductPrice.getPriceLimit.doubleValue())
      Then("the price list is : " + baseProductPrice.getPriceList)
      Then("the price std is : " + baseProductPrice.getPriceStd)
      Then("the price limit is : " + baseProductPrice.getPriceLimit)

      val baseFirstBreakValue = scala.BigDecimal(12.0)
      val baseFirstBreakPrice = scala.BigDecimal(8.0)
      val baseFirstBreakPriceStd = scala.BigDecimal(6.0)
      val baseFirstBreakPriceLimit = scala.BigDecimal(3.0)
      val baseSecondBreakValue = scala.BigDecimal(24.0)
      val baseSecondQuantityBreakValue = scala.BigDecimal(26.0)
      val baseSecondBreakPrice = scala.BigDecimal(6.0)
      val baseSecondBreakPriceStd = scala.BigDecimal(4.0)
      val baseSecondBreakPriceLimit = scala.BigDecimal(1.0)
      import org.eevolution.dsl.builder.PriceListProductBreakBuilder
      val baseFirstProductBreak = PriceListProductBreakBuilder()
        .withPriceListVersion(basePriceListVersion)
        .withProduct(newProduct)
        .withBreakValue(baseFirstBreakValue)
        .withPriceListAmount(baseFirstBreakPrice)
        .withPriceStdAmount(baseFirstBreakPriceStd)
        .withPriceLimitAmount(baseFirstBreakPriceLimit)
        .build()
      Given("a first product break value was created")
      assert(baseFirstProductBreak.getBreakValue.doubleValue() == baseFirstBreakValue.doubleValue())
      Then("first product break value is : " + baseFirstProductBreak.getBreakValue)
      assert(baseFirstProductBreak.getPriceList.doubleValue() == baseFirstBreakPrice.doubleValue())
      Then("first product break base price list" + baseFirstProductBreak.getPriceList)
      assert(baseFirstProductBreak.getPriceStd.doubleValue() == baseFirstBreakPriceStd.doubleValue())
      Then("first product break base standard price " + baseFirstProductBreak.getPriceStd)
      assert(baseFirstProductBreak.getPriceLimit.doubleValue() == baseFirstBreakPriceLimit.doubleValue())
      Then("first product break base price limit " + baseFirstProductBreak.getPriceLimit)
      val baseSecondProductBreak = PriceListProductBreakBuilder()
        .withPriceListVersion(basePriceListVersion)
        .withProduct(newProduct)
        .withBreakValue(baseSecondBreakValue)
        .withPriceListAmount(baseSecondBreakPrice)
        .withPriceStdAmount(baseSecondBreakPriceStd)
        .withPriceLimitAmount(baseSecondBreakPriceLimit)
        .build()
      Given("a second product break value was created")
      assert(baseSecondProductBreak.getBreakValue.doubleValue() == baseSecondBreakValue.doubleValue())
      Then("second product break value is : " + baseSecondProductBreak.getBreakValue)
      assert(baseSecondProductBreak.getPriceList.doubleValue() == baseSecondBreakPrice.doubleValue())
      Then("second product break price list" + baseSecondProductBreak.getPriceList)
      assert(baseSecondProductBreak.getPriceStd.doubleValue() == baseSecondBreakPriceStd.doubleValue())
      Then("second product break standatd price " + baseSecondProductBreak.getPriceStd)
      assert(baseSecondProductBreak.getPriceLimit.doubleValue() == baseSecondBreakPriceLimit.doubleValue())
      Then("second product break price limit " + baseSecondProductBreak.getPriceLimit)
      import org.eevolution.dsl.builder.PriceListBuilder
      val secondPriceListName = "Second Product break without vendor List Price"
      val secondPriceListDescription = "Second Product break without vendor List Price Description"
      val secondPriceList = PriceListBuilder()
        .withOrganization(HQ)
        .withName(secondPriceListName)
        .withDescription(secondPriceListDescription)
        .withCurrency(USDCurrency)
        .withPricePrecision(scala.BigDecimal(2))
        .asSalesPriceList()
        .build()
      assert(secondPriceListName == secondPriceList.getName)
      Then("the second price list name is : " + secondPriceList.getName)
      assert(secondPriceListDescription == secondPriceList.getDescription)
      Then("the second price list description is : " + secondPriceList.getDescription)
      val secondPriceListVersionName = "Second Product break with vendor Price List Version"
      val secondPriceListVersionDescription = "Second Product break with vendor Price List Version"
      val secondPriceListSchema = getPriceListSchemaByName("Sales 2001")
      assert(secondPriceListSchema != null)
      Then("the discount schema is : " + secondPriceListSchema.getName)
      import org.eevolution.dsl.builder.PriceListVersionBuilder
      val secondPriceListVersion = PriceListVersionBuilder()
        .withPriceList(secondPriceList)
        .withName(secondPriceListVersionName)
        .withDescription(secondPriceListVersionDescription)
        .withValidFrom(Yesterday)
        .withPriceListSchema(secondPriceListSchema)
        .withBasePriceListVersion(basePriceListVersion)
        .build()
      assert(secondPriceListVersionName == secondPriceListVersion.getName)
      Then("the second Product break with vendor price list version name is : " + secondPriceListVersion.getName)
      assert(secondPriceListVersionDescription == secondPriceListVersion.getDescription)
      Then("the second Product break with vendor price list version description is : " + secondPriceListVersion.getDescription)
      assert(secondPriceListVersion.getValidFrom.compareTo(Yesterday) <= 0)
      Then("the valid date is : " +  secondPriceListVersion.getValidFrom)
      assert(secondPriceListVersion.getM_Pricelist_Version_Base_ID== basePriceListVersion.get_ID)
      Then("the second price version : " + secondPriceListVersion.getName + " set as base price version the : " + basePriceListVersion.getName)
      val firstProductPricing = new ProductPricing(newProduct.get_ID, 0 , baseFirstBreakValue.bigDecimal, IsSOTrx, trxName)
      firstProductPricing.setM_PriceList_ID(secondPriceList.get_ID)
      firstProductPricing.setPriceDate(Today)
      firstProductPricing.calculatePrice()
      assert(firstProductPricing.getPriceList.doubleValue() == baseFirstBreakPrice.toDouble)
      Then(s"the new product first break value list price is :  $baseFirstBreakPrice")
      assert(firstProductPricing.getPriceStd.doubleValue() == baseFirstBreakPriceStd.toDouble)
      Then(s"the new product first break value standard price $baseFirstBreakPriceStd")
      assert(firstProductPricing.getPriceLimit.doubleValue() == baseFirstBreakPriceLimit.toDouble)
      Then(s"the new product first break value limit price $baseFirstBreakPriceLimit")
      val secondProductPricing = new ProductPricing(newProduct.get_ID, 0 , baseSecondQuantityBreakValue.bigDecimal, IsSOTrx, trxName)
      secondProductPricing.setM_PriceList_Version_ID(secondPriceListVersion.get_ID)
      secondProductPricing.setPriceDate(Today)
      secondProductPricing.calculatePrice()
      assert(baseSecondProductBreak.getPriceList.doubleValue() == baseSecondBreakPrice.toDouble)
      Then(s"the new product second break value list price is :  $baseSecondBreakPrice")
      assert(baseSecondProductBreak.getPriceStd.doubleValue() == baseSecondBreakPriceStd.toDouble)
      Then(s"the new product second break value  standard price $baseSecondBreakPriceStd")
      assert(baseSecondProductBreak.getPriceLimit.doubleValue() == baseSecondBreakPriceLimit.toDouble)
      Then(s"the new product second break value limit price $baseSecondBreakPriceLimit")
    }
    info("Creating a new Sales Price List with version with valid date Yesterday for the Oak and Azalea Products")
    info("Currently the prices for Oak are  price list 65 , standard price 61.75 with discount 59.90 and limit price 58.50")
    info("Currently the prices for Azalea are price list 25 , standard price 23.75 with discount 23.04 and limit price 22.50")
    scenario("Validate the functionality of 3% flat discount not based on a partner") {
      val IsSOTrx = true
      val PriceList = getListPriceByDefault(true)
      val Azalea = getProductByValue("Azalea Bush")
      val AzaleaListPrice = 25.0
      val AzaleaStandardPrice = 23.75
      val AzaleaLimitPrice = 22.50
      val AzaleaQuantity: BigDecimal = 1.0
      val flatDiscountName = "Flat discount 3%"
      val flatDiscountDescription = "Flat discount 3%"
      val flatDiscountGlobal = scala.BigDecimal(3)
      val AzaleaPriceStandardWithFlatDiscount = (AzaleaStandardPrice - (AzaleaStandardPrice * (flatDiscountGlobal / 100 ))).setScale(PriceList.getStandardPrecision, RoundingMode.HALF_UP)
      val seedFarmPartner = getPartnerByValue("SeedFarm")
      import org.eevolution.dsl.builder.DiscountSchemaBuilder
      val flatDiscountSchema  = DiscountSchemaBuilder()
        .withOrganization(Organization)
        .withName(flatDiscountName)
        .withDescription(flatDiscountDescription)
        .withDiscountType(X_M_DiscountSchema.DISCOUNTTYPE_FlatPercent)
        .withFlatDiscount(flatDiscountGlobal.bigDecimal)
        .build()
      assert(flatDiscountSchema.getName == flatDiscountName)
      Then("the flat discount schema was created " + flatDiscountName)
      assert(flatDiscountSchema.getDescription == flatDiscountDescription)
      Then("the flat discount schema was created with discription : " + flatDiscountName)
      assert(X_M_DiscountSchema.DISCOUNTTYPE_FlatPercent == flatDiscountSchema.getDiscountType )
      Then("the discount type is based on flat discount")
      assert(flatDiscountGlobal.doubleValue() == flatDiscountSchema.getFlatDiscount.doubleValue())
      Then("Discount flat is : " + flatDiscountSchema.getFlatDiscount)
      seedFarmPartner.setM_DiscountSchema_ID(flatDiscountSchema.get_ID)
      seedFarmPartner.saveEx()
      val AzaleaProductPricing = new ProductPricing(Azalea.get_ID, seedFarmPartner.get_ID(), AzaleaQuantity.bigDecimal, IsSOTrx , trxName)
      AzaleaProductPricing.setM_PriceList_ID(PriceList.get_ID)
      AzaleaProductPricing.setPriceDate(Today)
      AzaleaProductPricing.calculatePrice()
      val Oak = getProductByValue("Oak")
      val OakListPrice = 65
      val OakStandardPrice = 61.75
      val OakLimitPrice = 58.50
      val OakQuantity: BigDecimal = 1.0
      val OakPriceStandardWithFlatDiscount = (OakStandardPrice - (OakStandardPrice * (flatDiscountGlobal / 100))).setScale(PriceList.getStandardPrecision, RoundingMode.HALF_UP)
      val OakProductPricing = new ProductPricing(Oak.get_ID, seedFarmPartner.get_ID() , OakQuantity.bigDecimal, IsSOTrx, trxName)
      OakProductPricing.setM_PriceList_ID(PriceList.get_ID)
      OakProductPricing.setPriceDate(Today)
      OakProductPricing.calculatePrice()
      Given(s"that that date is $Today and the price list is standard")
      When("ask standard sales price for Oak")
      assert(PriceList.getName == "Standard")
      assert(PriceList.get_ID == AzaleaProductPricing.getM_PriceList_ID)
      Then("the price list is " + PriceList.getName)
      assert(AzaleaProductPricing.getPriceList.doubleValue() == AzaleaListPrice.doubleValue())
      Then(s"the Azalea product list price $AzaleaListPrice")
      assert(AzaleaProductPricing.getPriceStd.doubleValue() == AzaleaPriceStandardWithFlatDiscount.doubleValue())
      Then(s"the Azalea product standard price $AzaleaPriceStandardWithFlatDiscount")
      assert(AzaleaProductPricing.getPriceLimit.doubleValue() == AzaleaLimitPrice.toDouble)
      Then(s"the Azalea product limit price $AzaleaLimitPrice")
      assert(OakProductPricing.getPriceList.doubleValue() == OakListPrice.toDouble)
      Then(s"the Oak product list price $OakListPrice")
      assert(OakProductPricing.getPriceStd.doubleValue() == OakPriceStandardWithFlatDiscount.setScale(PriceList.getStandardPrecision, RoundingMode.HALF_UP).doubleValue())
      Then(s"the Oak product standard price $OakPriceStandardWithFlatDiscount")
      assert(OakProductPricing.getPriceLimit.doubleValue() == OakLimitPrice.toDouble)
      Then(s"the Oak product limit price $OakLimitPrice")
    }

    info("Creating a new Sales Price List with version with valid date Yesterday for the Oak and Azalea Products")
    info("Currently the prices for Oak are  price list 65 , standard price 61.75 with partner discount 58.66 and limit price 58.50")
    info("Currently the prices for Azalea are price list 25 , standard price 23.75 with partner discount 22.56 and limit price 22.50")
    scenario("Validate the functionality of 5% flat discount based on a partner") {
      val IsSOTrx = true
      val PriceList = getListPriceByDefault(true)
      val Azalea = getProductByValue("Azalea Bush")
      val AzaleaListPrice = 25.0
      val AzaleaStandardPrice = 23.75
      val AzaleaLimitPrice = 22.50
      val AzaleaQuantity: BigDecimal = 1.0
      val flatDiscountName = "Flat discount 5%"
      val flatDiscountDescription = "Flat discount 5%"
      val flatDiscountPartner = scala.BigDecimal(5)
      val AzaleaPriceStandardWithFlatDiscount = (AzaleaStandardPrice - (AzaleaStandardPrice * (flatDiscountPartner / 100 ))).setScale(PriceList.getStandardPrecision, RoundingMode.HALF_UP)
      val seedFarmPartner = getPartnerByValue("SeedFarm")
      import org.eevolution.dsl.builder.DiscountSchemaBuilder
      val flatDiscountSchema  = DiscountSchemaBuilder()
        .withOrganization(Organization)
        .withName(flatDiscountName)
        .withDescription(flatDiscountDescription)
        .withDiscountType(X_M_DiscountSchema.DISCOUNTTYPE_FlatPercent)
        .asPartnerFlatDiscount
        .withFlatDiscount(flatDiscountPartner.bigDecimal)
        .build()
      assert(flatDiscountSchema.getName == flatDiscountName)
      Then("the flat discount schema was created " + flatDiscountName)
      assert(flatDiscountSchema.getDescription == flatDiscountDescription)
      Then("the flat discount schema was created with discription : " + flatDiscountName)
      assert(X_M_DiscountSchema.DISCOUNTTYPE_FlatPercent == flatDiscountSchema.getDiscountType )
      Then("the discount type is based on flat discount")
      assert(flatDiscountPartner.doubleValue() == flatDiscountSchema.getFlatDiscount.doubleValue())
      Then("Discount flat is : " + flatDiscountSchema.getFlatDiscount)
      seedFarmPartner.setFlatDiscount(flatDiscountPartner.bigDecimal)
      seedFarmPartner.setM_DiscountSchema_ID(flatDiscountSchema.get_ID)
      seedFarmPartner.saveEx()
      val AzaleaProductPricing = new ProductPricing(Azalea.get_ID, seedFarmPartner.get_ID(), AzaleaQuantity.bigDecimal, IsSOTrx , trxName)
      AzaleaProductPricing.setM_PriceList_ID(PriceList.get_ID)
      AzaleaProductPricing.setPriceDate(Today)
      AzaleaProductPricing.calculatePrice()
      val Oak = getProductByValue("Oak")
      val OakListPrice = 65
      val OakStandardPrice = 61.75
      val OakLimitPrice = 58.50
      val OakQuantity: BigDecimal = 1.0
      val OakPriceStandardWithFlatDiscount = (OakStandardPrice - (OakStandardPrice * (flatDiscountPartner / 100))).setScale(PriceList.getStandardPrecision, RoundingMode.HALF_UP)
      val OakProductPricing = new ProductPricing(Oak.get_ID, seedFarmPartner.get_ID() , OakQuantity.bigDecimal, IsSOTrx, trxName)
      OakProductPricing.setM_PriceList_ID(PriceList.get_ID)
      OakProductPricing.setPriceDate(Today)
      OakProductPricing.calculatePrice()
      Given(s"that that date is $Today and the price list is standard")
      When("ask standard sales price for Oak")
      assert(PriceList.getName == "Standard")
      assert(PriceList.get_ID == AzaleaProductPricing.getM_PriceList_ID)
      Then("the price list is " + PriceList.getName)
      assert(AzaleaProductPricing.getPriceList.doubleValue() == AzaleaListPrice.doubleValue())
      Then(s"the Azalea product list price $AzaleaListPrice")
      assert(AzaleaProductPricing.getPriceStd.doubleValue() == AzaleaPriceStandardWithFlatDiscount.doubleValue())
      Then(s"the Azalea product standard price $AzaleaPriceStandardWithFlatDiscount")
      assert(AzaleaProductPricing.getPriceLimit.doubleValue() == AzaleaLimitPrice.toDouble)
      Then(s"the Azalea product limit price $AzaleaLimitPrice")
      assert(OakProductPricing.getPriceList.doubleValue() == OakListPrice.toDouble)
      Then(s"the Oak product list price $OakListPrice")
      assert(OakProductPricing.getPriceStd.doubleValue() == OakPriceStandardWithFlatDiscount.setScale(PriceList.getStandardPrecision, RoundingMode.HALF_UP).doubleValue())
      Then(s"the Oak product standard price $OakPriceStandardWithFlatDiscount")
      assert(OakProductPricing.getPriceLimit.doubleValue() == OakLimitPrice.toDouble)
      Then(s"the Oak product limit price $OakLimitPrice")
    }

    info("Creating a new Sales Price List with version with valid date Yesterday for the Oak and Azalea Products")
    info("Currently the prices for Azalea are price list 25 , standard price 23.75 with partner discount 22.56 and limit price 22.50")
    info("Currently the prices for Holly Bush are price list 40 , standard price 38 with partner discount 36.10 and limit price 26,00")
    info("Currently the prices for Oak are  price list 65 , standard price 61.75 with partner discount 58.66 and limit price 58.50")
    info("Azalea      35 quantity apply  2% discount ")
    info("Holly Bush  60 quantity apply  5% discount ")
    info("Oak        120 quantity apply 10% discount ")
    scenario("Validate functionality break discount based on a quantity") {
      val TreeProductCategory = getProductCategoryByValue("Bush")
      val IsSOTrx = true
      val PriceList = getListPriceByDefault(true)
      val flatDiscountName = "Flat discount 5%"
      val flatDiscountDescription = "Flat discount 5%"
      val flatDiscount30Units = scala.BigDecimal(2)
      val flatDiscount50Units = scala.BigDecimal(5)
      val flatDiscount100Units = scala.BigDecimal(10)
      val seedFarmPartner = getPartnerByValue("SeedFarm")
      import org.eevolution.dsl.builder.DiscountSchemaBuilder
      val flatDiscountSchema  = DiscountSchemaBuilder()
        .withOrganization(Organization)
        .withName(flatDiscountName)
        .withDescription(flatDiscountDescription)
        .withDiscountType(X_M_DiscountSchema.DISCOUNTTYPE_Breaks)
        .asQuantityBased
        .withAccumulationLevel(X_M_DiscountSchema.CUMULATIVELEVEL_Line)
        .build()
      assert(flatDiscountSchema.getName == flatDiscountName)
      Then("the flat discount schema was created " + flatDiscountName)
      assert(flatDiscountSchema.getDescription == flatDiscountDescription)
      Then(s"the flat discount schema was created with description : $flatDiscountDescription")
      assert(X_M_DiscountSchema.DISCOUNTTYPE_Breaks == flatDiscountSchema.getDiscountType )
      Then("the discount type is based on flat discount")

      val Azalea = getProductByValue("Azalea Bush")
      val AzaleaListPrice = 25.0
      val AzaleaStandardPrice = 23.75
      val AzaleaLimitPrice = 22.50
      val AzaleaQuantity: BigDecimal = 35.0
      val AzaleaPriceStandardWithFlatDiscount = (AzaleaStandardPrice - (AzaleaStandardPrice * (flatDiscount30Units / 100 ))).setScale(PriceList.getStandardPrecision, RoundingMode.HALF_UP)

      val HollyBush = getProductByValue("Holly Bush")
      val HollyBushListPrice = 40.0
      val HollyBushStandardPrice = 38
      val HollyBushLimitPrice = 36
      val HollyBushQuantity: BigDecimal = 60.0
      val HollyBushPriceStandardWithFlatDiscount = (HollyBushStandardPrice - (HollyBushStandardPrice * (flatDiscount50Units / 100))).setScale(PriceList.getStandardPrecision, RoundingMode.HALF_UP)

      val Oak = getProductByValue("Oak")
      val OakListPrice = 65
      val OakStandardPrice = 61.75
      val OakLimitPrice = 58.50
      val OakQuantity: BigDecimal = 120
      val OakPriceStandardWithFlatDiscount = (OakStandardPrice - (OakStandardPrice * (flatDiscount100Units / 100))).setScale(PriceList.getStandardPrecision, RoundingMode.HALF_UP)

      import org.eevolution.dsl.builder.DiscountSchemaBreakBuilder
      val firstDiscountBreak = DiscountSchemaBreakBuilder()
        .withDiscountSchema(flatDiscountSchema)
        .withSequenceNo(10)
        .withProduct(Oak)
        .withBreakValue(100)
        .withBreakDiscount(flatDiscount100Units)
        .build()
      When("the first discount break is created")
      assert(firstDiscountBreak.get_ID() > 0)
      assert(firstDiscountBreak.getSeqNo == 10)
      Then("then the sequence 10 is allowed")
      assert(firstDiscountBreak.getBreakDiscount.doubleValue() == flatDiscount100Units)
      Then("the break discount is of " + firstDiscountBreak.getBreakDiscount)

      val secondDiscountBreak = DiscountSchemaBreakBuilder()
        .withDiscountSchema(flatDiscountSchema)
        .withSequenceNo(20)
        .withProductCategory(TreeProductCategory)
        .withBreakValue(50)
        .withBreakDiscount(flatDiscount50Units)
        .build()

      When("the second discount break is created")
      assert(secondDiscountBreak.get_ID() > 0)
      assert(secondDiscountBreak.getSeqNo == 20)
      Then("the sequence 10 is allowed")
      assert(secondDiscountBreak.getBreakDiscount.doubleValue() == flatDiscount50Units)
      Then("the break discount is of " + secondDiscountBreak.getBreakDiscount)

      val thirdDiscountBreak = DiscountSchemaBreakBuilder()
        .withDiscountSchema(flatDiscountSchema)
        .withSequenceNo(30)
        .withBreakValue(30)
        .withBreakDiscount(flatDiscount30Units)
        .build()

      When("the third discount break is created")
      assert(thirdDiscountBreak.get_ID() > 0)
      assert(thirdDiscountBreak.getSeqNo == 30)
      Then("the sequence 10 is allowed")
      assert(thirdDiscountBreak.getBreakDiscount.doubleValue() == flatDiscount30Units)
      Then("the break discount is of " + thirdDiscountBreak.getBreakDiscount)

      seedFarmPartner.setFlatDiscount(scala.BigDecimal(0).bigDecimal)
      seedFarmPartner.setM_DiscountSchema_ID(flatDiscountSchema.get_ID())
      seedFarmPartner.saveEx()

      val AzaleaProductPricing = new ProductPricing(Azalea.get_ID, seedFarmPartner.get_ID(), AzaleaQuantity.bigDecimal, IsSOTrx , trxName)
      AzaleaProductPricing.setM_PriceList_ID(PriceList.get_ID)
      AzaleaProductPricing.setPriceDate(Today)
      AzaleaProductPricing.calculatePrice()

      Given(s"that that date is $Today and the price list is standard")
      When("ask standard sales price for Oak")
      assert(PriceList.getName == "Standard")
      assert(PriceList.get_ID == AzaleaProductPricing.getM_PriceList_ID)
      Then("the price list is " + PriceList.getName)
      assert(AzaleaProductPricing.getPriceList.doubleValue() == AzaleaListPrice.doubleValue())
      Then(s"the Azalea product list price $AzaleaListPrice")
      assert(AzaleaProductPricing.getPriceStd.doubleValue() == AzaleaPriceStandardWithFlatDiscount.doubleValue())
      Then(s"the Azalea product standard price $AzaleaPriceStandardWithFlatDiscount")
      assert(AzaleaProductPricing.getPriceLimit.doubleValue() == AzaleaLimitPrice.toDouble)
      Then(s"the Azalea product limit price $AzaleaLimitPrice")

      val HollyBushProductPricing = new ProductPricing(HollyBush.get_ID, seedFarmPartner.get_ID() , HollyBushQuantity.bigDecimal, IsSOTrx, trxName)
      HollyBushProductPricing.setM_PriceList_ID(PriceList.get_ID)
      HollyBushProductPricing.setPriceDate(Today)
      HollyBushProductPricing.calculatePrice()
      HollyBushProductPricing.getDiscount()

      Given(s"that that date is $Today and the price list is standard")
      When("ask standard sales price for Oak")
      assert(PriceList.getName == "Standard")
      assert(PriceList.get_ID == HollyBushProductPricing.getM_PriceList_ID)
      Then("the price list is " + PriceList.getName)
      assert(HollyBushProductPricing.getPriceList.doubleValue() == HollyBushListPrice.doubleValue())
      Then(s"the Azalea product list price $HollyBushListPrice")
      assert(HollyBushProductPricing.getPriceStd.doubleValue() == HollyBushPriceStandardWithFlatDiscount.doubleValue())
      Then(s"the Azalea product standard price $HollyBushPriceStandardWithFlatDiscount")
      assert(HollyBushProductPricing.getPriceLimit.doubleValue() == HollyBushLimitPrice.toDouble)
      Then(s"the Azalea product limit price $HollyBushLimitPrice")

      val OakProductPricing = new ProductPricing(Oak.get_ID, seedFarmPartner.get_ID() , OakQuantity.bigDecimal, IsSOTrx, trxName)
      OakProductPricing.setM_PriceList_ID(PriceList.get_ID)
      OakProductPricing.setPriceDate(Today)
      OakProductPricing.calculatePrice()

      assert(OakProductPricing.getPriceList.doubleValue() == OakListPrice.toDouble)
      Then(s"the Oak product list price $OakListPrice")
      assert(OakProductPricing.getPriceStd.doubleValue() == OakPriceStandardWithFlatDiscount.setScale(PriceList.getStandardPrecision, RoundingMode.HALF_UP).doubleValue())
      Then(s"the Oak product standard price $OakPriceStandardWithFlatDiscount")
      assert(OakProductPricing.getPriceLimit.doubleValue() == OakLimitPrice.toDouble)
      Then(s"the Oak product limit price $OakLimitPrice")
    }
    info("Creating a new Sales Price List with version with valid date Yesterday for the Oak , Holly Bush  and Azalea Products")
    info("Currently the prices for Azalea are price list 25 , standard price 23.75 with partner discount 22.56 and limit price 22.50")
    info("Currently the prices for Holly Bush are price list 40 , standard price 38 with partner discount 36.10 and limit price 26,00")
    info("Currently the prices for Oak are  price list 65 , standard price 61.75 with partner discount 58.66 and limit price 58.50")
    info("The discount flat for Seed farm is defined on 15% ")
    info("Azalea      35 quantity apply  2% discount ")
    info("Holly Bush  60 quantity apply  5% discount ")
    info("Oak        120 quantity apply 10% discount ")
    scenario("Validate functionality break discount based on a partner") {
      val TreeProductCategory = getProductCategoryByValue("Bush")
      val IsSOTrx = true
      val PriceList = getListPriceByDefault(true)
      val flatDiscountName = "Flat discount 5%"
      val flatDiscountDescription = "Flat discount 5%"
      val flatDiscount30Units = scala.BigDecimal(2)
      val flatDiscount50Units = scala.BigDecimal(5)
      val flatDiscount100Units = scala.BigDecimal(10)
      val seedFarmDiscount = scala.BigDecimal(15)
      val seedFarmPartner = getPartnerByValue("SeedFarm")
      import org.eevolution.dsl.builder.DiscountSchemaBuilder
      val flatDiscountSchema  = DiscountSchemaBuilder()
        .withOrganization(Organization)
        .withName(flatDiscountName)
        .withDescription(flatDiscountDescription)
        .withDiscountType(X_M_DiscountSchema.DISCOUNTTYPE_Breaks)
        .asQuantityBased
        .withAccumulationLevel(X_M_DiscountSchema.CUMULATIVELEVEL_Line)
        .build()
      assert(flatDiscountSchema.getName == flatDiscountName)
      Then("the flat discount schema was created " + flatDiscountName)
      assert(flatDiscountSchema.getDescription == flatDiscountDescription)
      Then(s"the flat discount schema was created with description : $flatDiscountDescription")
      assert(X_M_DiscountSchema.DISCOUNTTYPE_Breaks == flatDiscountSchema.getDiscountType )
      Then("the discount type is based on flat discount")

      val Azalea = getProductByValue("Azalea Bush")
      val AzaleaListPrice = 25.0
      val AzaleaStandardPrice = 23.75
      val AzaleaLimitPrice = 22.50
      val AzaleaQuantity: BigDecimal = 35.0
      val AzaleaPriceStandardWithFlatDiscount = (AzaleaStandardPrice - (AzaleaStandardPrice * (seedFarmDiscount / 100 ))).setScale(PriceList.getStandardPrecision, RoundingMode.HALF_UP)

      val HollyBush = getProductByValue("Holly Bush")
      val HollyBushListPrice = 40.0
      val HollyBushStandardPrice = 38
      val HollyBushLimitPrice = 36
      val HollyBushQuantity: BigDecimal = 60.0
      val HollyBushPriceStandardWithFlatDiscount = (HollyBushStandardPrice - (HollyBushStandardPrice * (seedFarmDiscount / 100))).setScale(PriceList.getStandardPrecision, RoundingMode.HALF_UP)

      val Oak = getProductByValue("Oak")
      val OakListPrice = 65
      val OakStandardPrice = 61.75
      val OakLimitPrice = 58.50
      val OakQuantity: BigDecimal = 120
      val OakPriceStandardWithFlatDiscount = (OakStandardPrice - (OakStandardPrice * (seedFarmDiscount / 100))).setScale(PriceList.getStandardPrecision, RoundingMode.HALF_UP)

      import org.eevolution.dsl.builder.DiscountSchemaBreakBuilder
      val firstDiscountBreak = DiscountSchemaBreakBuilder()
        .withDiscountSchema(flatDiscountSchema)
        .withSequenceNo(10)
        .withProduct(Oak)
        .withBreakValue(100)
        .asPartnerFlatDiscount
        .withBreakDiscount(flatDiscount100Units)
        .build()
      When("the first discount break is created")
      assert(firstDiscountBreak.get_ID() > 0)
      assert(firstDiscountBreak.getSeqNo == 10)
      Then("then the sequence 10 is allowed")
      assert(firstDiscountBreak.getBreakDiscount.doubleValue() == flatDiscount100Units)
      Then("the break discount is of " + firstDiscountBreak.getBreakDiscount)

      val secondDiscountBreak = DiscountSchemaBreakBuilder()
        .withDiscountSchema(flatDiscountSchema)
        .withSequenceNo(20)
        .withProductCategory(TreeProductCategory)
        .withBreakValue(50)
        .asPartnerFlatDiscount
        .withBreakDiscount(flatDiscount50Units)
        .build()

      When("the second discount break is created")
      assert(secondDiscountBreak.get_ID() > 0)
      assert(secondDiscountBreak.getSeqNo == 20)
      Then("the sequence 10 is allowed")
      assert(secondDiscountBreak.getBreakDiscount.doubleValue() == flatDiscount50Units)
      Then("the break discount is of " + secondDiscountBreak.getBreakDiscount)

      val thirdDiscountBreak = DiscountSchemaBreakBuilder()
        .withDiscountSchema(flatDiscountSchema)
        .withSequenceNo(30)
        .withBreakValue(30)
        .asPartnerFlatDiscount
        .withBreakDiscount(flatDiscount30Units)
        .build()

      When("the third discount break is created")
      assert(thirdDiscountBreak.get_ID() > 0)
      assert(thirdDiscountBreak.getSeqNo == 30)
      Then("the sequence 10 is allowed")
      assert(thirdDiscountBreak.getBreakDiscount.doubleValue() == flatDiscount30Units)
      Then("the break discount is of " + thirdDiscountBreak.getBreakDiscount)

      seedFarmPartner.setFlatDiscount(seedFarmDiscount.bigDecimal)
      seedFarmPartner.setM_DiscountSchema_ID(flatDiscountSchema.get_ID())
      seedFarmPartner.saveEx()

      val AzaleaProductPricing = new ProductPricing(Azalea.get_ID, seedFarmPartner.get_ID(), AzaleaQuantity.bigDecimal, IsSOTrx , trxName)
      AzaleaProductPricing.setM_PriceList_ID(PriceList.get_ID)
      AzaleaProductPricing.setPriceDate(Today)
      AzaleaProductPricing.calculatePrice()

      Given(s"that that date is $Today and the price list is standard")
      When("ask standard sales price for Oak")
      assert(PriceList.getName == "Standard")
      assert(PriceList.get_ID == AzaleaProductPricing.getM_PriceList_ID)
      Then("the price list is " + PriceList.getName)
      assert(AzaleaProductPricing.getPriceList.doubleValue() == AzaleaListPrice.doubleValue())
      Then(s"the Azalea product list price $AzaleaListPrice")
      assert(AzaleaProductPricing.getPriceStd.doubleValue() == AzaleaPriceStandardWithFlatDiscount.doubleValue())
      Then(s"the Azalea product standard price $AzaleaPriceStandardWithFlatDiscount")
      assert(AzaleaProductPricing.getPriceLimit.doubleValue() == AzaleaLimitPrice.toDouble)
      Then(s"the Azalea product limit price $AzaleaLimitPrice")

      val HollyBushProductPricing = new ProductPricing(HollyBush.get_ID, seedFarmPartner.get_ID() , HollyBushQuantity.bigDecimal, IsSOTrx, trxName)
      HollyBushProductPricing.setM_PriceList_ID(PriceList.get_ID)
      HollyBushProductPricing.setPriceDate(Today)
      HollyBushProductPricing.calculatePrice()
      HollyBushProductPricing.getDiscount()

      Given(s"that that date is $Today and the price list is standard")
      When("ask standard sales price for Oak")
      assert(PriceList.getName == "Standard")
      assert(PriceList.get_ID == HollyBushProductPricing.getM_PriceList_ID)
      Then("the price list is " + PriceList.getName)
      assert(HollyBushProductPricing.getPriceList.doubleValue() == HollyBushListPrice.doubleValue())
      Then(s"the Azalea product list price $HollyBushListPrice")
      assert(HollyBushProductPricing.getPriceStd.doubleValue() == HollyBushPriceStandardWithFlatDiscount.doubleValue())
      Then(s"the Azalea product standard price $HollyBushPriceStandardWithFlatDiscount")
      assert(HollyBushProductPricing.getPriceLimit.doubleValue() == HollyBushLimitPrice.toDouble)
      Then(s"the Azalea product limit price $HollyBushLimitPrice")

      val OakProductPricing = new ProductPricing(Oak.get_ID, seedFarmPartner.get_ID() , OakQuantity.bigDecimal, IsSOTrx, trxName)
      OakProductPricing.setM_PriceList_ID(PriceList.get_ID)
      OakProductPricing.setPriceDate(Today)
      OakProductPricing.calculatePrice()

      assert(OakProductPricing.getPriceList.doubleValue() == OakListPrice.toDouble)
      Then(s"the Oak product list price $OakListPrice")
      assert(OakProductPricing.getPriceStd.doubleValue() == OakPriceStandardWithFlatDiscount.setScale(PriceList.getStandardPrecision, RoundingMode.HALF_UP).doubleValue())
      Then(s"the Oak product standard price $OakPriceStandardWithFlatDiscount")
      assert(OakProductPricing.getPriceLimit.doubleValue() == OakLimitPrice.toDouble)
      Then(s"the Oak product limit price $OakLimitPrice")
    }
  }
}
